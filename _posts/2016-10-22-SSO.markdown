---
layout: post
title:  "SSO"
date:   2016-10-21 13:00:15
description: "sso"
permalink: post/sso
disqus:
  id: sso
categories:
- php
---

Web SSO(Single Sign On)
=======================


SSO
----

WEB应用中,多个应用系统需要同一个登陆系统,这就是SSO.<br>

一般解决办法是固定一个二级域名,通过cookie和分布式session(一般存到redis中)来解决问题.<br>

但是多个应用系统是异构的,cookie和session是不通用的,上面的方式没法解决.<br>

下面,讲一下大概的思路.

用户首次登录时流程如下：

- 用户浏览器访问系统A需登录受限资源。

- 系统A发现该请求需要登录,将请求重定向到认证中心,进行登录.

- 认证中心呈现登录页面,用户登录,登录成功后,认证中心重定向请求到系统A,并附上认证通过令牌.

- 系统A与认证中心通信,验证令牌有效,证明用户已登录.

- 系统A将受限资源返给用户.

已登录用户首次访问应用群中系统B时：

- 浏览器访问另一应用B需登录受限资源.

- 系统B发现该请求需要登录,将请求重定向到认证中心,进行登录.

- 认证中心发现已经登录,即重定向请求响应到系统B,附带上认证令牌.

- 系统B与认证中心通信,验证令牌有效,证明用户已登录.

- 系统B将受限资源返回给客户端.

登出流程如下：

- 客户端向应用A发送登出Logout请求.

- 应用A取消本地会话,同时通知认证中心,用户已登出。

- 应用A返回客户端登出请求.

- 认证中心通知所有用户登录访问的应用,用户已登出.

用户到认证中心登录后,用户和认证中心之间建立起了会话,把这个会话称为全局会话.当用户后续访问系统应用时，不可能每次应用请求都到认证中心去判定是否登录,这样效率非常低下,这也是单Web应用不需要考虑的.可以在系统应用和用户浏览器之间建立起局部会话,局部会话保持了客户端与该系统应用的登录状态,局部会话依附于全局会话存在,全局会话消失.局部会话必须消失.用户访问应用时,首先判断局部会话是否存在.如存在,即认为是登录状态,无需再到认证中心去判断.如不存在，就重定向到认证中心判断全局会话是否存在,如存在,通知该应用,该应用与客户端就建立起它们之间局部会话.下次请求该应用.就不去认证中心验证了.<br>


CAS(Central Authentication Server)中央认证服务
=============================================

对于全局会话,CAS基于Cookie使用了自己的实现方式,而服务端的会话存储,除了缺省基于内存模式,还提供了基于ehcache、memcached等多种实现,同时提供了灵活接口便于自己定制扩展,这非常适合某些高可用性、高性能的应用场景.

CAS原理和上面基本一致,所有的系统应用都会引导到CAS Server认证中心去登录.登录成功后,认证中心会产生一个票据叫TGT(Ticket Granting Ticket),TGT即代表了用户与认证中心直接的全局会话.TGT存在,表明该用户处于登录状态.

TGT并没有放在Session中,也就是说,CAS全局会话的实现并没有直接使用Session机制,而是利用了Cookie自己实现的,这个Cookie叫做TGC(Ticket Granting Cookie),它存放了TGT的id,认证中心服务端实现了TGT.

更多的内容只能去看文档.
